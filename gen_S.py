# %%
import numpy as np
import copy
import matplotlib.pyplot as plt
from wlpy.gist import heatmap

# %%
def cov2cor(S: np.ndarray):
    # Covariance to Correlation
    D = np.diag(np.sqrt(np.diag(S)))
    D_inv = np.linalg.inv(D)
    return D_inv @ S @ D_inv
# %%
def make_cov_PD(A, eps = 0.01):
    N = A.shape[0]
    assert A.shape == (N, N) and np.allclose(A, A.T)
    a = max(0, - np.min(np.linalg.eigvals(A))) + eps
    # print(a)
    return A + a * np.eye(N)  
# %%
def gen_S_AR1(rho: float, N: int, cut: int = None) -> np.ndarray:
    # self covariance matrix of AR(1) process
    S_block = np.zeros(shape = [N, N])
    for j in range(N):
        S_block = S_block + np.diag(np.ones(N - j) * (rho ** j), -j) + np.diag(np.ones(N - j) * (rho ** j), j)
    S = S_block - np.eye(N)
    if cut:
        i_indices, j_indices = np.indices((N, N))
        S[np.abs(i_indices - j_indices) > cut] = 0
    return S
# %%
def gen_S_Cai2011Adaptive_Model1(N: int, t: int = 10, a1: int = 1, a2: int = 4) -> np.ndarray:
    """
    Args:
        t: Bandwidth of the block matrix A1.
        ai: amplitude

    Returns:
        numpy.ndarray: 
    """
    Nh = N // 2
    A1 = np.zeros(shape = (Nh, Nh))
    for j in range(Nh):
        sigma = max(0, 1 - j / t) * a1
        A1 = A1 + np.diag(np.ones(Nh - j) * sigma, -j) + np.diag(np.ones(Nh - j) * sigma, j)
    A1 = A1 - np.eye(Nh)
    A2 = np.eye(Nh) * a2
    S = np.zeros(shape = (N, N))
    S[0:Nh, 0:Nh] = A1
    S[Nh:N, Nh:N] = A2
    return S

if __name__ == '__main__':
    S = gen_S_Cai2011Adaptive_Model1(500)
    heatmap(S)
  
# %%
def gen_S_Cai2011Adaptive_Model2(N: int, intU: tuple = (0.3, 0.8), probB: float = 0.05, a1: float = 1, a2: float = 4, seed: int = None) -> np.ndarray:
    """
    Args:
        intU: The range of uniform distribution, for off-diagonal entries only.
        probB: The probability in Bernoulli distribution.

    Returns:
        numpy.ndarray: 
    """
    Nh = N // 2
    rng = np.random.RandomState(seed)
    A2 = np.eye(Nh) * a2

    Bu = np.triu(rng.uniform(low = intU[0], high = intU[1], size = (Nh, Nh)) * rng.binomial(n = 1, p = probB, size = (Nh, Nh)), k = 1) # upper triangular matrix, without diagonal

    B = Bu + Bu.T + np.eye(Nh) * a1 # symmetric matrix

    A1 = make_cov_PD(B)

    S = np.zeros(shape = (N, N))
    S[0:Nh, 0:Nh] = A1
    S[Nh:N, Nh:N] = A2
    return S

if __name__ == '__main__':
    S = gen_S_Cai2011Adaptive_Model2(500)
    heatmap(S)
    # print(S.T == S)
    # print(S)

# %%
def gen_S_Bernoulli(N: int, a: float = 1, aB: float = 0.9, probB: float = 0.05, seed: int = None) -> np.ndarray:
    """
    This function returns a positive-definite matrix, whose off-diagonal entries are generated according to Bernoulli distribution.

    Args:
        a: amplitude of diagonal entries
        aB: amplitude of off-diagonal entries, generated by Bernoulli  distribution
        probB: probability parameter of Bernoulli distribution 

    Returns:
        numpy.ndarray:
    """
    rng = np.random.RandomState(seed)

    Bu = np.triu(rng.binomial(n = 1, p = probB, size = (N, N)), k = 1) * aB
    B = Bu + Bu.T + np.eye(N) * a
    S = make_cov_PD(B)
    return S

if __name__ == '__main__':
    S = gen_S_Bernoulli(100)
    # print(S)
    heatmap(S)

# %%
def gen_S_Cai2011Adaptive_Model2_my(N, a1 = 1, a1B = 0.9, probB = 0.05, a2 = 4, seed: int = None):
    """
    Similar to the covariance matrix generated by <gen_S_Cai2011Adaptive_Model2>, but here substitute block A1 with <gen_S_Bernoulli>.
    """
    Nh = N // 2
    rng = np.random.RandomState(seed)
    A2 = np.eye(Nh) * a2
    
    A1 = gen_S_Bernoulli(Nh, a = a1, aB = a1B, probB = probB, seed = seed)
    S = np.zeros(shape = (N, N))
    S[0:Nh, 0:Nh] = A1
    S[Nh:N, Nh:N] = A2
    return S

if __name__ == '__main__':
    S = gen_S_Cai2011Adaptive_Model2_my(500)
    heatmap(S)
# %%
def gen_S_arrow(N, n1 = 5, rho = 0.9, c = 0.3, a1 = 4, a2 = 0):
    S1 = gen_S_AR1(rho = rho, N = n1) * a1
    A = np.ones((N - n1, n1)) * c
    I = np.eye(N - n1) * a2
    S = np.vstack((np.hstack((S1, A.T)), np.hstack((A, I))))
    S = make_cov_PD(S)
    assert not np.iscomplex(S).any()
    S = S.astype(np.float64)
    return S
if __name__ == '__main__':
    S = gen_S_arrow(100, n1 = 5)
    heatmap(S);
    heatmap(S.clip(0, 0.3));
# %%
for rho in [0.9, 0.5]:
    S = gen_S_arrow(500, rho = rho)
    assert S.dtype == np.float64
    print(rho)
    n1 = 5
    print(S.max(), S[n1+1, n1+1])
# %%
4*3*3*3*3
# %%
